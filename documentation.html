<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>HiCAL - A System for Efficient High-Recall Retrieval</title>

    <!-- Bootstrap & Font Awesome CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="static/style.css">


</head>
<body>
    <div class="navbar-container">
        <nav class="navbar navbar-toggleable-md navbar-light ml-4 mr-4">
            <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="index.html"><h1><span>Hi</span>CAL</h1></a>
                <span class="navbar-text  mb-3">
                    <span class=" mr-1"></span> A System for Efficient High-Recall Retrieval.
                  </span>

            <div class="navbar-toggler-right" id="navbarText">
                <ul class="navbar-nav mr-auto mb-3">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">How to</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="#">Documentation<span class="sr-only">(current)</span></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="paper.html">Paper</a>
                    </li>

                </ul>

            </div>
        </nav>
    </div>

    <div class="content">
        <h2>Architecture</h2>
           <p>The figure below shows the high-level architecture of the system.</p>

        <div class="row">
            <div class="col-md-6">
                <figure class="figure">
                  <img src="images/architecure.png" class="figure-img img-fluid rounded p-1 border gray-background">
                </figure>
            </div>
            <div class="col-md-6">
                <p>Figure 1: Platform server (i.e. <a href="http://www.github.com/hical/hical/HiCALWeb">HiCAL-web</a>) responsible for displaying content and communicating requests and responses between components.
                CAL component (i.e. <a href="">HiCAL-engine</a>) responsible for training and ranking documents.
                The Search component is a query-based search engine responsible for retrieving document and ranking documents.
                </p>
            </div>
        </div>

        <h4>HiCAL-web</h4>
        <h5>Setting up</h5>
        <p>
            The platform requires a database for logging and storing document judgments.
            Install postgres and run it, make sure you create a db called <code>HiCAL</code>, or whatever you have set in <a href="">settings</a>.
        </p>
        <p>
            To create a db, use this command:
        </p>
        <pre><code>$ createdb HiCAL </code></pre>

        <p>Create a python3 virtual env, and pip install everything in <code>requirements/base.txt:</code></p>
        <pre><code>$ pip install -r requirements/base.txt</code></pre>

        <p>If you are running it locally, you might also want to install everything in <code>requirements/local.txt:</code></p>

        <pre><code>$ pip install -r requirements/local.txt</code></pre>

        <p>
            Your local db is initially empty, and you will need to create the tables according to the models.
            To do this, run <code>python manage.py makemigrations</code> and then <code>python manage.py migrate.</code>
        </p>

        <p>
            For running a uwsgi instance, <code>uwsgi --socket 127.0.0.1:8001 --module config.wsgi --master --process 2 --threads 4</code>
        </p>

        <p>To run locally, run <code>python manage.py runserver</code></p>

        <h5>Setting Up Your Users</h5>
            <p>Each document judgments is associated with a user profile.</p>

        <p>To create a normal user account, just go to Sign Up and fill out the form.</p>

        <p>To create an superuser account, use this command:</p>

        <pre><code>$ python manage.py createsuperuser</code></pre>

        <p>For convenience, you can keep your normal user logged in on Chrome and your superuser logged in on Firefox (or similar), so that you can see how the site behaves for both kinds of users. A superuser can access the platform's admin page by going to <code>/admin</code> or whatever is set in the settings.</p>

        <h6>Configuring Signup Form</h6>

        <p><code>users.models.User</code> contains the custom user model that you can modify to your need. <code>allauth.forms.SignupForm</code> is a custom signup form that you can change to include extra information that will be saved in the user model.</p>

        <p>Registration and account management is done using django-allauth.</p>

        <h5>Component Settings</h5>
        <p>Communication from and to the component are done through http requests.</p>
        <p>Make sure you update the IPs for each component in the <code>config/settings/base.py</code> file.</p>
<pre>
<code>
# CORE TREC COMPONENTS IPS *REQUIRED*
# ------------------------------------------------------------------------------
CAL_SERVER_IP = '127.0.0.0'
CAL_SERVER_PORT = '9001' # The port for CAL engine
SEARCH_SERVER_IP = '127.0.0.0'
SEARCH_SERVER_PORT = '80'
DOCUMENTS_URL = '127.0.0.0:9000/doc'
PARA_URL = '127.0.0.0:9000/para'
</code>
</pre>



        <h5>Logging</h5>

        <p>We use python’s built in logging module for system and analytics logging. You can configure logging from the project settings in <code>settings/base.py</code>.
        <p>The repo currently has one logging handle. Logs are saved in <code>logs/web.log</code>.</p>
        <p>Check <code>config/settings/base.py</code> for more logging configurations</p>

        <h6>Using the logger</h6>

        <p>Once you have configured your logger, you can start placing logging calls into your code. This is very simple to do. Here’s an example:</p>
<pre>
<code>
import logging
logger = logging.getLogger(__name__)

class JudgmentAJAXView(views.CsrfExemptMixin, views.LoginRequiredMixin,
                       views.JsonRequestResponseMixin,
                       generic.View):

    # some code
    ...

    # log message
    log_message = {
        "user": self.request.user.username,
        "client_time": client_time,
         # ...
        }
    }
    # log message
    logger.info("{}".format(json.dumps(log_message)))
</code>
</pre>

        <p>We suggest you follow a simple logging style that you can easily parse and understand. Place logging message where ever you need to log/track changes in the systems or user behaviour.</p>


    <h5>Components</h5>

        <p>Our system currently supports two retrieval components, CAL and Search.
            All components in the architecture are stand-alone and interact with each other via HTTP API.
            You can also add your own component and run it locally if you wish.
        </p>

        <h6>Adding a component</h6>
        <p>Let’s go through an example of adding a new component. For simplicity, the component will simply return a list of predefine documents that need to be judged. The component will allow user to access and judge these documents in the order they are define. We’ll call this component Iterative.</p>

        <p>Let’s add a new app in our project by running this command:</p>

<pre><code>$ python manage.py createapp iterative</code></pre>

<p>This will create a folder with all the files we need. Make sure the newly created app is in the right directory. It should be in /HiCAL.</p>
<p>Let’s add the new app to our settings file so that our server is aware of it. You can do this by going to <code>config/settings/base.py</code> file and adding <code>HiCAL.iterative</code> to <code>LOCAL_APPS</code>:

<pre>
<code>
# Apps specific for this project go here.
LOCAL_APPS = [
    # custom users app
    ...
    'hical.iterative',
]
</code>
</pre>

        <p>Now add a specific url for the app in <code>config/urls.py</code>:</p>
<pre>
<code>
urlpatterns = [
    ...
    # add this
    url(r'^iterative/', include('treccoreweb.iterative.urls', namespace='iterative')),

]
</code>
</pre>

    <p>and create a new <code>urls.py</code> file under the iterative app directory:</p>

<pre>
<code>
from django.conf.urls import url

from treccoreweb.iterative import views

urlpatterns = [
    url(r'^$', views.HomePageView.as_view(), name='main'),

    # Ajax views
    url(r'^post_log/$', views.MessageAJAXView.as_view(), name='post_log_msg'),
    url(r'^get_docs/$', views.DocAJAXView.as_view(), name='get_docs'),
]
</code>
</pre>

<p>This will allow access to the component from the url <code>/iterative/</code></p>

<p>We will use <code>get_docs/</code> url pattern to link to our view <code>DocAJAXView</code>, which will be responsible for getting the documents to judge. Please look at <code>iterative/views.py</code> for more details on what these views do.</p>

<p>Let’s look at <code>DocAJAXView</code> view as an example:</p>

<pre>
<code>
from interfaces.DocumentSnippetEngine import functions as DocEngine
from interfaces.Iterative import functions as IterativeEngine

class DocAJAXView(views.CsrfExemptMixin, views.LoginRequiredMixin,
                  views.JsonRequestResponseMixin,
                  views.AjaxResponseMixin, generic.View):
    """
    View to get a list of documents to judge
    """
    require_json = False

    def render_timeout_request_response(self, error_dict=None):
        if error_dict is None:
            error_dict = self.error_response_dict
        json_context = json.dumps(
            error_dict,
            cls=self.json_encoder_class,
            **self.get_json_dumps_kwargs()
        ).encode('utf-8')
        return HttpResponse(
            json_context, content_type=self.get_content_type(), status=502)

    def get_ajax(self, request, *args, **kwargs):
        try:
            current_task = self.request.user.current_task
            docs_ids = IterativeEngine.get_documents(current_task.topic.number)
            docs_ids = helpers.remove_judged_docs(docs_ids,
                                                  self.request.user,
                                                  current_task)
            documents = DocEngine.get_documents(docs_ids, query=None)
            return self.render_json_response(documents)
        except TimeoutError:
            error_dict = {u"message": u"Timeout error. Please check status of servers."}
            return self.render_timeout_request_response(error_dict)
</code>
</pre>

<p>The method get_ajax will be called from our template to retrieve a list of documents. The variable docs_ids contains the list of documents ids that we need to retrieve their content. We put all functions associated with the component retrieval in <code>/interfaces</code> directory.</p>

<p>The variable documents will contain a list of documents with their content, in the following format:</p>

<pre>
<code>
[
    {
        'doc_id': "012345",
        'title': "Document Title",
        'content': "Body of document",
        'date': "Date of document"
    },
    ...
]
</code>
</pre>

<p>documents will be passed as context to our template, and loaded in the browser.</p>

<p>The HTML associated is under <code>iterative/templates/iterative/iterative.html</code>. The <code>HomePageView</code> view, which the url pattern <code>/iterative/^</code> is pointing to, will render this page. If you look at the <code>HomePageView</code> view, you will see that <code>template_name = 'iterative/iterative.html'</code>.</p>

<p>You can modify the iterative.html as you like. The <code>iterative.html</code> file will call <code>iterative:get_docs</code> once the page is loaded. You can customize the behaviour by modifying the javascript code in <code>iterative.html</code> to meet your needs.</p>

<p>The judgment buttons in the interface will call the <code>send_judgment()</code> function, which will send a call to the url <code>judgment:post_judgment</code> in <code>judgments/url.py</code> and run the view <code>JudgmentAJAXView</code>, which will save the document judgment to the database. If you would like to include more information to be saved with each judgment, you can modify the <code>send_judgment()</code> in <code>iterative.html</code>. You will also need to modify the database model, Judgement, associated with each judgment instance. The Judgement class is located in <code>judgment/models.py</code>.</p>


        <h6>CAL and Search</h6>
<p>Both components follow a similar pattern as the Iterative component described above. The difference is that both are running somewhere else, and we need to make an http calls to get the documents we need to judge. The IPs for each component is set in <code>config/settings/base.py</code>. The methods used to retrieve documents are found in <code>/interfaces/</code>.</p>

<p>The HTML associated with each component is found under the templates folder under the component directory.</p>
    </div>

    <div class="content">
        <ul class="sm" style="list-style: none;">
            <li>
                <a href="https://github.com/HiCAL" target="_blank"><i class="fa fa-github"></i></a> <span class="ml-3">/</span>
            </li>
            <li class="small mt-1">
                GitHub code.
            </li>
            <li class="small mt-1">
                GNU General Public License v3.0
            </li>
        </ul>
        <p class="copy"></p>
    </div>

</body>
</html>
